# ðŸ“Œ 1ï¸âƒ£ Gerekli KÃ¼tÃ¼phaneleri YÃ¼kleyelim
!pip install -q xgboost lightgbm numpy pandas scikit-learn tensorflow torch transformers ta yfinance

# ðŸ“Œ 2ï¸âƒ£ KÃ¼tÃ¼phaneleri Ä°Ã§eri AktaralÄ±m
import numpy as np
import pandas as pd
import tensorflow as tf
import torch
import ta  # Teknik analiz iÃ§in
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import LSTM, Dense, Dropout
from sklearn.ensemble import IsolationForest
from xgboost import XGBRegressor
from sklearn.preprocessing import MinMaxScaler
from transformers import AutoModelForSequenceClassification, AutoTokenizer
import yfinance as yf

# ðŸ“Œ 3ï¸âƒ£ Binance Piyasa Verilerini Ã‡ekme ve Teknik GÃ¶stergeleri Hesaplama
def fetch_market_data():
    """BTC fiyatlarÄ±nÄ± Ã§eker ve teknik gÃ¶stergeleri ekler"""
    data = yf.download("BTC-USD", start="2022-01-01", end="2024-01-01")

    # ðŸ“Œ 3.1 RSI Hesaplama
    data["RSI"] = ta.momentum.RSIIndicator(data["Close"], window=14).rsi()

    # ðŸ“Œ 3.2 Bollinger Bands Hesaplama
    bb = ta.volatility.BollingerBands(data["Close"], window=20, window_dev=2)
    data["Bollinger_Upper"] = bb.bollinger_hband()
    data["Bollinger_Lower"] = bb.bollinger_lband()

    # ðŸ“Œ 3.3 MACD Hesaplama
    macd = ta.trend.MACD(data["Close"])
    data["MACD"] = macd.macd()
    data["MACD_Signal"] = macd.macd_signal()

    # ðŸ“Œ 3.4 VWAP Hesaplama
    vwap = ta.volume.VolumeWeightedAveragePrice(data["High"], data["Low"], data["Close"], data["Volume"], window=14)
    data["VWAP"] = vwap.volume_weighted_average_price()

    # Eksik verileri doldurma
    data.fillna(0, inplace=True)

    # Verileri normalize etme
    scaler = MinMaxScaler()
    data_scaled = scaler.fit_transform(data[["Close", "RSI", "Bollinger_Upper", "Bollinger_Lower", "MACD", "MACD_Signal", "VWAP"]])

    return data_scaled

# ðŸ“Œ 4ï¸âƒ£ LSTM Modeli ile Fiyat Tahmini
def train_lstm(data):
    """LSTM modelini eÄŸitir"""
    X_train, y_train = [], []
    for i in range(60, len(data)):
        X_train.append(data[i-60:i])
        y_train.append(data[i, 0])

    X_train, y_train = np.array(X_train), np.array(y_train)

    lstm_model = Sequential([
        LSTM(50, return_sequences=True, input_shape=(X_train.shape[1], X_train.shape[2])),
        Dropout(0.2),
        LSTM(50),
        Dense(1)
    ])
    lstm_model.compile(optimizer="adam", loss="mean_squared_error")
    lstm_model.fit(X_train, y_train, epochs=5, batch_size=32, verbose=1)
    return lstm_model

# ðŸ“Œ 5ï¸âƒ£ XGBoost Modeli ile Fiyat Tahmini
def train_xgboost(data):
    """XGBoost modelini eÄŸitir"""
    X_train, y_train = [], []
    for i in range(60, len(data)):
        X_train.append(data[i-60:i].flatten())
        y_train.append(data[i, 0])

    X_train, y_train = np.array(X_train), np.array(y_train)

    xgb_model = XGBRegressor(n_estimators=200)
    xgb_model.fit(X_train, y_train)
    return xgb_model

# ðŸ“Œ 6ï¸âƒ£ Anomaly Detection (AutoEncoder / Isolation Forest)
def detect_anomalies(data):
    """Piyasa manipÃ¼lasyonlarÄ±nÄ± tespit eder"""
    model = IsolationForest(contamination=0.05, random_state=42)
    anomalies = model.fit_predict(data)
    return anomalies

# ðŸ“Œ 7ï¸âƒ£ Lokal BERT Modeli ile Haber Analizi
tokenizer = AutoTokenizer.from_pretrained("nlptown/bert-base-multilingual-uncased-sentiment")
model = AutoModelForSequenceClassification.from_pretrained("nlptown/bert-base-multilingual-uncased-sentiment")

def get_sentiment(text):
    """BERT Modeli ile haber duygu analizi yapar"""
    inputs = tokenizer(text, return_tensors="pt")
    with torch.no_grad():
        output = model(**inputs)
    return output.logits.argmax().item()

# ðŸ“Œ 8ï¸âƒ£ AI Destekli Ticaret Stratejisi
def ai_trading_strategy():
    """AI Modeli ile piyasa analizi yaparak ticaret kararlarÄ±nÄ± belirler"""
    data = fetch_market_data()
    lstm_model = train_lstm(data)
    xgb_model = train_xgboost(data)
    sentiment_score = get_sentiment("Bitcoin is bullish today!")  # Ã–rnek haber analizi
    anomaly_score = detect_anomalies(data)

    lstm_pred = lstm_model.predict(np.array([data[-60:]]))[0][0]
    xgb_pred = xgb_model.predict(np.array([data[-60:].flatten()]))[0]

    if lstm_pred > data[-1, 0] and xgb_pred > data[-1, 0] and sentiment_score == 1 and anomaly_score[-1] == 1:
        return "LONG"
    elif lstm_pred < data[-1, 0] and xgb_pred < data[-1, 0] and sentiment_score == -1 and anomaly_score[-1] == -1:
        return "SHORT"
    else:
        return "NEUTRAL"

# ðŸ“Œ 9ï¸âƒ£ AI Modeli Testi
decision = ai_trading_strategy()
print(f"ðŸ“ˆ AI KararÄ±: {decision}")
